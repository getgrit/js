language js

// A call to `add`/`sub` method of a `momentjs` date object.
pattern moment_arith($date, $method, $count, $pat) {
  `$date.$method($count, $pat)` as $arith_exp where {
    $method <: or { `add`, `sub` },
    if ($method <: `add`) {
      $method <: ensure_import_from(source=`"date-fns/add"`),
    } else {
      $method <: ensure_import_from(source=`"date-fns/sub"`),
    },
    $pat <: string()
  }
}

// A call to `add/sub` where the caller (`this`) is an identifier. eg: foo.add(bar);
pattern moment_arith_lhs_identifier($date, $method, $count, $pat) {
  moment_arith($date, $method, $count, $pat) where {
    $date <: identifier()
  }
}

// A `const` variable declaration that initializes a moment date object
pattern moment_const_decl($declaration, $declarators) {
  `$varName = $moment()` where {
    $moment <: or { `moment`, `$_.duration` },
    $varName <: within `$declaration` where { $declaration <: `const $declarators` },
  }
}

// Matches calls like `moment.startOf('day')`, `moment.startOf('week')`
pattern moment_set_to_start_or_end_literal($date, $func_type, $unit) {
  `$date.$func_type($specifier)` where {
    $func_type <: or { `startOf`, `endOf` },
    $specifier<: string(fragment=$unit)
  }
}

// moment.max(...) or moment.min(...)
pattern moment_limit_to_max_or_min($date, $arg, $methodName) {
  `$date.$methodName($arg)` where {
    or { $methodName <: "max", $methodName <: "min" }
  }
}

pattern moment_set_or_get($duration_or_date, $accessor, $accessor_fn, $arg) {
   `$duration_or_date.$accessor($arg)` where {
    $accessor <: r"(year|month|week|day|hour|minute|second|millisecond)s?"($unit),
    $capitalized_unit = capitalize(string=$unit),
    $accessor_fn = join(list=["get", $capitalized_unit, "s"], separator=""),
    $accessor = join(list=[$unit, "s"], separator="")
  } => `(x => (x instanceof Date) ? datefns.$accessor_fn(x) : x.$accessor)($duration_or_date)`,
}

// Helper patterns to match format specifiers for different time units in moment js:
pattern year() { string(fragment=r"\b(?:y|years?)\b") }
pattern month() { string(fragment=r"\b(?:M|months?)\b") }
pattern quarter() { string(fragment=r"\b(?:q|quarters?)\b") }
pattern week() { string(fragment=r"\b(?:w|weeks?)\b") }
pattern day() { string(fragment=r"\b(?:d|days?)\b") }
pattern hour() { string(fragment=r"\b(?:h|hours?)\b") }
pattern minute() { string(fragment=r"\b(?:m|minutes?)\b") }
pattern second() { string(fragment=r"\b(?:s|seconds?)\b") }
pattern millisecond() { string(fragment=r"\b(?:ms|milliseconds?)\b") }

pattern regex_year() { r"\b(?:(?i)y|years?)\b" }
pattern regex_month() { r"\b(?:M|(?i)months?)\b" }
pattern regex_week() { r"\b(?:(?i)w|weeks?)\b" }
pattern regex_date() { r"\b(?:(?i)d|dates?)\b"  }
pattern regex_day() { r"\b(?:(?i)d|day?)\b"  }
pattern regex_hour() { r"\b(?:(?i)h|hours?)\b" }
pattern regex_minute() { r"\b(?:(?i)m|minutes?)\b" }
pattern regex_second() { r"\b(?:(?i)s|seconds?)\b" }
pattern regex_ms() { r"\b(?:(?i)ms|milliseconds?)\b" }

// convert a moment.js unit specifier to its normal form ("y" -> "year")
pattern normalize_unit_specifier() {
  or {
    year() => `year`,
    quarter() => `quarter`,
    month() => `month`,
    week() => `week`,
    day() => `day`,
    hour() => `hour`,
    minute() => `minute`,
    second() => `second`,
    millisecond() => `millisecond`
  }
}

// add/subtract: convert all momentjs arithmetic operations to date-fns operations.
// eg: today.add(oneday) => add(today, oneday)
pattern rewrite_moment_arithmetic() {
  or {
    // add/subtract: convert all momentjs arithmetic operations to date-fns operations.
    // eg: today.add(oneday) => add(today, oneday)
    moment_arith($date, $method, $count, $pat) as $expression where {
      $pat <: or {
        year() => `years`,
        quarter() => `quarters`,
        month() => `months`,
        week() => `weeks`,
        day() => `days`,
        hour() => `hours`,
        minute() => `minutes`,
        second() => `seconds`,
      },

      $out = `$method($date, { $pat: $count })`,

      if ($date <: identifier()) {
        $out = `$date = $method($date, { $pat: $count })`
      },
      // If the arithmetic expression is not an expression statement,
      // wrap it in `()`, as `=` has very low precedence.
      if ($date <: not within expression_statement($expression)) {
        $out = `($out)`
      }
    } => `$out`,

    moment_arith($date, $method, $count, $pat) where {
      $pat <: string(fragment=$frag where { $frag <: r"\b(?:ms|milliseconds?)\b"}),
      $out = `$method($date, { seconds: $count / 1000 })`,
      if ($date <: identifier()) {
        $out = `$date = $out`
      },
      if ($date <: not within expression_statement($expression)) {
        $out = `($out)`
      }
    } => `$out`,

    `$date_a.diff($date_b, $literal_unit)` where { $literal_unit <: string() }  => `datefns.differenceIn$literal_unit($date_a, $date_b)` where {
      $literal_unit <: or {
        year() => `Years`,
        quarter() => `Quarters`,
        month() => `Months`,
        week() => `Weeks`,
        day() => `Days`,
        hour() => `Hours`,
        minute() => `Minutes`,
        second() => `Seconds`,
        millisecond() => `Milliseconds`
      }
    },

    // When no unit is specified, `diff` returns difference in ms.
    `$date_a.diff($date_b)` where { $date_b <: [$_] /* exactly one argument */ } => `datefns.differenceInMilliseconds($date_a, $date_b)`,
  }
}

pattern rewrite_moment_getters_and_setters() {
  or {
    `$date.daysInMonth()` => `datefns.getDaysInMonth($date)`,
      // case: when `d` is a `Moment`:
      // d.milliseconds() -> datefns.getMilliseconds(date);
      // d.millisecond() -> datefns.getMilliseconds(date);
      // case: when `d` is `Duration`.
      // d.milliseconds() -> duration.milliseconds;
      moment_set_or_get($duration_or_date, $accessor, $accessor_fn, $arg) where {
        $arg <: .
      } => `((x => (x instanceof Date) ? datefns.$accessor_fn(x) : x.$accessor)($duration_or_date))`,

      // re-write set calls when caller is an identifier
      moment_set_or_get(duration_or_date=$d, $accessor, $accessor_fn, $arg) where {
        $arg <: [$_], // at least 1 argument
        $out = `/* TODO: date-fns objects are immutable - feed this value back through properly */ (d => ((d instanceof Date) ? datefns.$accessor_fn(d) : d.$accessor))($d)`,
        if ($d <: identifier()) {
          $out = `($d = (($d instanceof Date) ? datefns.$accessor_fn($d) : $d.$accessor))`
        }
      } => `$out`,

      `$date.$func($arg)` where {
        $func <: or {
          r"dates?" => `Month`,
          r"(?:days?)|(?:weekdays?)" => `Day`,
          `isoWeekday` => `ISODay`,
          `dayOfYear` => `DayOfYear`,
          `weekOfYear` => `WeekOfYear`,
          r"isoWeeks?" => `ISOWeek`,
          r"weeks?" => `Week`
        },
        $out = `/*TODO: date-fns objects are immutable, feed this value back through properly*/ datefns.set$func($date, $arg)`,

        // no-args => it's a getter call
        if ($arg <: .) {
          $out = `datefns.get$func($date)`
        } else if ($date <: identifier()) {
          // Presence of arguments implies a setter call.
          // Identifiers can be re-assigned to.
          $out = `($date = datefns.set$func($date, $arg))`
        }
      }  => `$out`,

      // There are no setters for the number of ISO Weeks in an year.
      `$date.$method()` where { $method <: or { `weeksInYear`, `isoWeeksInYear` } } => `datefns.getISOWeeksInYear($date)`,

      // TODO: support `.get(x)` calls when `x` isn't a literal.
      `$date.get($unit)` where {
        $unit <: string(fragment=$norm_unit),
        $norm_unit <: or {
          // units in a momentjs getter are case insensitive and allow plural forms
          r"(?i)years?"  => `years`,
          r"(?i)months?"  => `months`,
          r"(?i)dates?"  => `date`,
          r"(?i)hours?"  => `hours`,
          r"(?i)minutes?"  => `minutes`,
          r"(?i)seconds?"  => `seconds`,
          r"(?i)milliseconds?"  => `milliseconds`,
        },
        $capitalized_unit = capitalize(string=$norm_unit),
        $date_get_fn = `datefns.get$capitalized_unit`,
    } => `((d => (d instanceof Date) ? $date_get_fn(d) : (d.$norm_unit ?? 0))($date))`,

    // TODO: support `x.set(unit, val)` calls when `unit` isn't a literal.
    `$date.set($unit, $value)` where {
      $unit <: string(fragment=$setter),
      $setter <: or {
        // units in a momentjs getter are case insensitive and allow plural forms
        r"(?i)years?"  => `setYear`,
        r"(?i)months?"  => `setMonth`,
        r"(?i)dates?"  => `setDate`,
        r"(?i)hours?"  => `setHours`,
        r"(?i)minutes?"  => `setMinutes`,
        r"(?i)seconds?"  => `setSeconds`,
        r"(?i)milliseconds?"  => `setMilliseconds`,
      },
      $out = `/* TODO: date-fns objects are immutable, propagate this value appropriately */ datefns.$setter($date, $value)`,
      if ($date <: identifier()) {
        $out = `($date = datefns.$setter($date, $value))`
      }
    } => `$out`,
  }
}

pattern rewrite_duration_set_and_get() {
  `$duration.$getter()` where {
    $getter <: or {
      `asMilliseconds` => `toMilliseconds`,
      `asSeconds` => `toSeconds`,
      `asMinutes` => `toMinutes`,
      `asHours` => `toHours`,
      `asDays` => `toDays`,
      `asWeeks` => `toWeeks`,
      `asMonths` => `toMonths`,
      `asYears` => `toYears`,
    }
  } => `durationfns.$getter($duration)`,
}

pattern rewrite_misc_methods() {
  `$d.toJSON()` => `dateOrDuration2JSON($d)` 
}

pattern rewrite_moment_queries() {
  or {
    `$date_a.$compare($date_b)` where {
      $compare <: or { `isBefore`, `isAfter` }
    } => `datefns.$compare($date_a, $date_b)`,

    `$date_a.$compare($date_b)` where {
      $compare <: or {
        `isSameOrBefore` => `isBefore`,
        `isSameOrAfter` => `isAfter`
      }
    // NOTE: since `a` and `b` are evaluated twice, it is safer to use an IIFE here for correctness.
    } => `((a, b) => datefns.isEqual(a, b) || datefns.$compare(a, b))($date_a, $date_b)`,

    `$date.isBetween($start_date, $end_date)` => `((date) => datefns.isAfter(date, $start_date) && datefns.isBefore(date, $end_date))($date)`,
    `$date.isLeapYear()` => `datefns.isLeapYear($date)`,
    `$isMoment($arg)` where { $isMoment <: or { `$_.isMoment`, `isMoment` }  } => `(($arg) instanceof Date)`,
  }
}

pattern rewrite_moment_distance() {
  `$date.toNow()` => `datefns.formatDistanceToNow($date)`,
  `$date_a.from($date_b)` => `(datefns.formatDistance($date_a, $date_b) + " ago")`,
  `$date_a.to($date_b)` => `datefns.formatDistance($date_a, $date_b)`,
}

pattern rewrite_duration_ctors() {
  or {
    // NOTE: date-fns only provides a `Duration` object ([docs](https://date-fns.org/v2.30.0/docs/Duration)).
    // Curiously, it does not provide any helpers to manipulate these duration objects.
    // For that, we use a third party package called [duration-fns](https://www.npmjs.com/package/duration-fns).
    `$duration_ctor($count, $literal_unit)` where {
      // could be moment.duration(...) (default import) or duration(..)
      $duration_ctor <: or { `$_.duration`, `duration` },
      // TODO: handle the case where the unit is not a literal (or a compile time constant).
      $literal_unit <: or {
        year() => `years`,
        month() => `months`,
        week() => `weeks`,
        day() => `days`,
        hour() => `hours`,
        minute() => `minutes`,
        second() => `seconds`,
        millisecond() => `milliseconds`
      },
      // $durationfns = "durationfns",
      // $durationfns <: ensure_import_from(source=`"duration-fns"`),

      // A duration in `date-fns` is a mapping from time units to values (e.g: { years: 1 }).
      // NOTE: This is an implementation detail, and is not documented in the library itself,
      // but date-fns does not expose any way to construct a duration by fiat.
      // Complementary libraries like `duration-fns` also rely on this internal representation, though.
      // So we should be good here.
      // ([source](https://github.com/date-fns/date-fns/blob/817ce9fda6dc11336923f80b45d34bf7c5a57886/src/types.ts#L58))
    } => `({ $literal_unit: $count })`,

    `$duration_ctor($empty)` where {
      $duration_ctor <: or { `$_.duration`, `duration` },
      $empty <: . // no arguments
    } => `({})`
  }
}

pattern rewrite_const_to_let() {
  moment_const_decl($declaration, $declarators) where { $declaration => `let $declarators` }
}

pattern rewrite_moment_imports() {
  or {
    `const $id = require("moment")` => `const datefns = require("date-fns");\nconst durationfns = require("duration-fns")`,
    // TODO: only add a default import of `duration-fns` if neccessary.
    `import $_ from "moment"` => `import datefns from "date-fns";\n import durationfns from "duration-fns";`,
  }
}

pattern moment_exp_to_datefns_exp() {
  or {
    // TODO: back-track the origin of an identifier and mutate the declaration on-demand.
    moment_const_decl($declaration, $declarators) where { $declaration => `let $declarators` },

    // Formatting
    `$date.format($fmt)` as $fmt_exp where {
      $date <: identifier(),
      $fmt_exp => `($date = $date.format($fmt))`
    },

    // parsing:
    // date-fns uses different format to parse dates.
    // https://github.com/date-fns/date-fns/blob/main/docs/unicodeTokens.md
    // momentjs: https://momentjs.com/docs/#/parsing/string-format/
    // TODO: This needs more work, the two format specifications have more differences.
    `moment($str, $fmt)` => `datefns.parse($str, ($fmt).replace(/D/g, "d").replace(/Y/g, "y").replace(/h/g, "H").replace(/x/g, "T"), new Date())`,
    
    // construction
    `moment($arg)` => `(new Date($arg))`,

    // convert all .add/.sub calls to date-fns equivalent calls.
    rewrite_moment_arithmetic(),

    // start/end setters where the time unit is a literal (e.g: d.startOf("week"))
    moment_set_to_start_or_end_literal($date, $func_type, $unit) as $expression where {
      $date <: identifier(),
      $unit_name = `Year`,
      $setter_fn = `setYear`,

      if ($unit <: regex_month()) {
        $unit_name = `Month`,
        $setter_fn = `setMonth`,
      } else if ($unit <: regex_week()) {
        $unit_name = `Week`,
        $setter_fn = `setWeek`
      } else if ($unit <: regex_day()) {
        $unit_name = `Day`,
        $setter_fn = `setDay`
      } else if ($unit <: regex_hour()) {
        $unit_name = `Hour`,
        $setter_fn = `setHours`
      } else if ($unit <: regex_minute()) {
        $unit_name = `Minute`,
        $setter_fn = `setMinutes`
      } else if ($unit <: regex_second()) {
        $unit_name = `Second`,
        $setter_fn = `setSeconds`
      },

      $setter = `datefns.$setter_fn`,
      $getter = `datefns.$func_type$unit_name`,
      $out = `/* TODO: date-fns objects are immutable, propagate this value appropriately */ (d => $setter(d, $getter(d)))($date)`,
      if ($date <: identifier()) {
        $out = `$date = $setter($date, $getter($date))`,
        if ($date <: not within expression_statement($expression)) {
         $out = `($out)`
        }
      }
    } => `$out`,

    // date.max(other_date) -> (date = datefns.max(date, other_date))
    moment_limit_to_max_or_min($date, $arg, $methodName) where { $date <: identifier() } => `$date = datefns.$methodName([$date, $arg])`,

    // distance to/from a given date.
    rewrite_moment_distance(),
    
    // NOTE: `valueOf` is a prototype function for pretty much any JavaScript value.
    // To ensure that our program behaves correctly, we first check if the caller is a `Date` object before
    // dispatching to the datefns `getTime` function. An IIFE is used to avoid evaluating `$date` twice since
    // the evaluation may have side effects.
    `$date.valueOf()` => `(d => ((d instanceof Date) ? datefns.getTime(d) : d.valueOf())($date))`,
    `$date.unix()` => `datefns.getUnixTime($date)`,
    `$date.daysInMonth()` => `datefns.getDaysInMonth($date)`,
    `$date.toDate()` => `($date)`,
    `$date.toISOString()` => `datefns.formatISO($date)`,
    `$date.toObject()` => `((d => ({ years: datefns.getYears(d), months: datefns.getMonths(d), hours: datefns.hours(d), minutes: datefns.minutes(d), seconds: datefns.seconds(d), milliseconds: datefns.getMilliseconds(d) }))($date))`,

    // Queries:
    rewrite_moment_queries(),

    // Durations API
    rewrite_duration_ctors(),

    // convert all specific getters/setters to date-fns equivalent
    // TODO: Using a helper, convert `.get`/`.set` calls where the argument isn't a literal.
    // e.g: `moment().get(alert())`.
    rewrite_moment_getters_and_setters(),
    rewrite_duration_set_and_get(),

    // rewrite util functions that do not belong to any specific category.
    rewrite_misc_methods(),
  }
}

pattern add_helper_functions() {
  program() as $prog where {
    // If the program contains a call to `.toJSON`, add our own helper.
    
    $func = `function dateOrDuration2JSON(d) {
  if (d instanceof Date) {
    return datefns.formatISO(d);
  } else if (durationfns.UNITS.some((unit) => Object.hasOwnProperty.call(d, unit))) {
    return durationfns.toJSON(d)
  }

  return d.toJSON()
}`,
    $out = `$prog`,
    if ($prog <: contains `dateOrDuration2JSON($_)`) {
      $out = `$prog\n/* Helper function inserted by Grit: */\n$func`
    } 
  } => `$out`
}
