language js

// A call to `add`/`sub` method of a `momentjs` date object.
pattern moment_arith($date, $method, $count, $specifier) {
  `$date.$method($count, $specifier)` as $arith_exp where {
    $method <: or { `add` => `addDate`, `subtract` => `subDate` },
    if ($method <: `add`) {
      $add = `add`,
      $add <: ensure_import_from(source=`"date-fns/add"`),
    } else {
      $sub = `sub`,
      $sub <: ensure_import_from(source=`"date-fns/sub"`),
    }
  }
}

// Matches any statement that should end in a semi-colon to avoid possible ambiguity.
// For example, in the following snippet:
// ```
// let a = foo()
// (x => print(x))("hello")
// ```
// The second "statement" is actually a call expression that is chained to the `foo` call:
// ```
// let a = foo()(x => print(x))("hello")
// ```
// Hence, the first statement should end in a semi colon to avoid ambiguity.
pattern should_follow_semi() {
  `$exp` where {
    $exp <: after or {
      expression_statement(),
      lexical_declaration()
    }
  }
}

// A call to `add/sub` where the caller (`this`) is an identifier. eg: foo.add(bar);
pattern moment_arith_lhs_identifier($date, $method, $count, $specifier) {
  moment_arith($date, $method, $count, $specifier) where {
    $date <: identifier()
  }
}

// A `const` variable declaration that initializes a moment date object
pattern moment_const_decl($declaration, $declarators) {
  `$varName = $moment()` where {
    $moment <: or { `moment`, `$_.duration`, `$_.clone` },
    $varName <: within `$declaration` where { $declaration <: `const $declarators` },
  }
}

// Matches calls like `moment.startOf('day')`, `moment.startOf('week')`
pattern moment_set_to_start_or_end_literal($date, $func_type, $unit) {
  `$date.$func_type($specifier)` where {
    $func_type <: or { `startOf`, `endOf` },
    $specifier<: string(fragment=$unit)
  }
}

// moment.max(...) or moment.min(...)
pattern moment_limit_to_max_or_min($date, $arg, $methodName) {
  `$date.$methodName($arg)` where {
    $methodName  <: or { `max`, `min` }
  }
}

// Helper patterns to match format specifiers for different time units in moment js:
pattern year() { string(fragment=r"\b(?:y|years?)\b") }
pattern month() { string(fragment=r"\b(?:M|months?)\b") }
pattern quarter() { string(fragment=r"\b(?:q|quarters?)\b") }
pattern week() { string(fragment=r"\b(?:w|weeks?)\b") }
pattern day() { string(fragment=r"\b(?:d|days?)\b") }
pattern hour() { string(fragment=r"\b(?:h|hours?)\b") }
pattern minute() { string(fragment=r"\b(?:m|minutes?)\b") }
pattern second() { string(fragment=r"\b(?:s|seconds?)\b") }
pattern millisecond() { string(fragment=r"\b(?:ms|milliseconds?)\b") }

pattern regex_year() { r"\b(?:(?i)y|years?)\b" }
pattern regex_month() { r"\b(?:M|(?i)months?)\b" }
pattern regex_week() { r"\b(?:(?i)w|weeks?)\b" }
pattern regex_date() { r"\b(?:(?i)d|dates?)\b"  }
pattern regex_day() { r"\b(?:(?i)d|days?)\b"  }
pattern regex_hour() { r"\b(?:(?i)h|hours?)\b" }
pattern regex_minute() { r"\b(?:(?i)m|minutes?)\b" }
pattern regex_second() { r"\b(?:(?i)s|seconds?)\b" }
pattern regex_ms() { r"\b(?:(?i)ms|milliseconds?)\b" }

pattern moment_set_or_get() {
  `$d.$accessor($arg)` as $exp where {
    $accessor <: r"(year|month|week|day|hour|minute|second|millisecond)s?"($unit),
    $duration_accessor = join(list=[$unit, "s"], separator=""),
    if ($unit <: or { "hour", "minute", "second", "millisecond" } ) {
      $unit = $duration_accessor
    },
    $cap_unit = capitalize(string=$unit),
    $getfn = `get$cap_unit`,
    $setfn = `set$cap_unit`,
    $out = ``,
    if ($arg <: .) {
      // getter call
      if ($d <: identifier()) {
        $out = `(($d instanceof Date) ? datefns.$getfn($d) : ($d.$duration_accessor ?? 0))`,
        if ($exp <: should_follow_semi()) {
          $out = `;\n$out`
        }
      } else {
        $out = `(d => (d instanceof Date) ? datefns.$getfn(d) : (d.$duration_accessor ?? 0))($d)`
      }
    } else {
      // setter call
      if ($d <: identifier()) {
        if ($arg <: or { literal(), identifier() } ) {
          $out = `(($d instanceof Date) ? ($d = $d.$setfn($arg)) : ($d.$duration_accessor = $arg))`
        } else {
          // the argument might be an expression with side effects, and hence must be evaluated only once using an IIFE
          $out = `((() => ($d instanceof Date) ? ($d = $d.$setfn(val)) : ($d.$duration_accessor = val))(val))`
        }
      } else {
        $comment = `/* TODO: moment-js objects are mutable - feed this value through appropriately */`,
        $out = `(((d, val) => (d instanceof Date) ? d.$setfn(val) : (d.$duration_accessor = val))($d, $arg))`,
        if ($out <: should_follow_semi()) {
          $out = `$comment\n$out`
        } else {
          $out = `$comment $out`
        }
       
      },

      if ($out <: should_follow_semi()) {
        $out = `;\n$out`
      }
    }
  } => `$out`,
}

// convert a moment.js unit specifier to its normal form ("y" -> "year")
pattern normalize_unit_specifier() {
  or {
    year() => `year`,
    quarter() => `quarter`,
    month() => `month`,
    week() => `week`,
    day() => `day`,
    hour() => `hour`,
    minute() => `minute`,
    second() => `second`,
    millisecond() => `millisecond`
  }
}

// add/subtract: convert all momentjs arithmetic operations to date-fns operations.
// eg: today.add(oneday) => add(today, oneday)
pattern rewrite_moment_arithmetic() {
  or {
    // add/subtract: convert all momentjs arithmetic operations to date-fns operations.
    // eg: today.add(oneday) => add(today, oneday)
    moment_arith($date, $method, $count, $specifier) as $expression where {
      $specifier <: and {
        string(),
        or {
          year() => `years`,
          quarter() => `quarters`,
          month() => `months`,
          week() => `weeks`,
          day() => `days`,
          hour() => `hours`,
          minute() => `minutes`,
          second() => `seconds`,
          millisecond() => `milliseconds`
        }
      },

      $out = `$method($date, { $specifier: $count })`,

      if ($date <: identifier()) {
        $out = `$date = $method($date, { $specifier: $count })`
      },
      // If the arithmetic expression is not an expression statement,
      // wrap it in `()`, as `=` has very low precedence.
      if ($date <: not within expression_statement($expression)) {
        $out = `($out)`
      }
    } => `$out`,

    moment_arith($date, $method, $count, $specifier) where {
      !$specifier <: string(),
      $out = `$method($date, { [normalizeMomentJSUnit($specifier) + 's']: $count })`,
      if ($date <: identifier()) { $out = `$date = $out`},
      if ($date <: not within expression_statement($expression)) {
        $out = `($out)`
      }
    } => `$out`,

    `$date_a.diff($date_b, $literal_unit)` where { $literal_unit <: string() }  => `datefns.differenceIn$literal_unit($date_a, $date_b)` where {
      $literal_unit <: or {
        year() => `Years`,
        quarter() => `Quarters`,
        month() => `Months`,
        week() => `Weeks`,
        day() => `Days`,
        hour() => `Hours`,
        minute() => `Minutes`,
        second() => `Seconds`,
        millisecond() => `Milliseconds`
      }
    },

    // When no unit is specified, `diff` returns difference in ms.
    `$date_a.diff($date_b)` where { $date_b <: [$_] /* exactly one argument */ } => `datefns.differenceInMilliseconds($date_a, $date_b)`,
  }
}

pattern rewrite_moment_getters_and_setters() {
  or {
    `$date.daysInMonth()` => `datefns.getDaysInMonth($date)`,
    // case: when `d` is a `Moment`:
    // d.milliseconds() -> datefns.getMilliseconds(date);
    // d.millisecond() -> datefns.getMilliseconds(date);
    // case: when `d` is `Duration`.
    // d.milliseconds() -> duration.milliseconds;
    moment_set_or_get(),

    `$date.$func($arg)` as $exp where {
      $func <: or {
        r"dates?" => `Month`,
        r"(?:days?)|(?:weekdays?)" => `Day`,
        `isoWeekday` => `ISODay`,
        `dayOfYear` => `DayOfYear`,
        `weekOfYear` => `WeekOfYear`,
        r"isoWeeks?" => `ISOWeek`,
        r"weeks?" => `Week`
      },

      $comment = `/*TODO: date-fns objects are immutable, feed this value back through properly*/`,
      $out = `datefns.set$func($date, $arg)`,

      // no-args => it's a getter call
      if ($arg <: .) {
        $out = `datefns.get$func($date)`
      } else if ($date <: identifier()) {
        // Presence of arguments implies a setter call.
        // Identifiers can be re-assigned to.
        $out = `($date = datefns.set$func($date, $arg))`
      } else if ($exp <: should_follow_semi()) {
        $out = `$comment\n$out`
      } else {
        $out = `$comment $out`
      }
    }  => `$out`,

    // There are no setters for the number of ISO Weeks in an year.
    `$date.$method()` where { $method <: or { `weeksInYear`, `isoWeeksInYear` } } => `datefns.getISOWeeksInYear($date)`,

    // TODO: support `.get(x)` calls when `x` isn't a literal.
    `$date.get($unit)` where {
      $unit <: string(fragment=$norm_unit),
      $norm_unit <: or {
        // units in a momentjs getter are case insensitive and allow plural forms
        regex_year()  => `years`,
        regex_month()  => `months`,
        regex_date()  => `date`,
        regex_hour()  => `hours`,
        regex_minute()  => `minutes`,
        regex_second()  => `seconds`,
        regex_ms() => `milliseconds`,
      },
      $capitalized_unit = capitalize(string=$norm_unit),
      $date_get_fn = `datefns.get$capitalized_unit`,
  } => `((d => (d instanceof Date) ? $date_get_fn(d) : (d.$norm_unit ?? 0))($date))`,

  // TODO: support `x.set(unit, val)` calls when `unit` isn't a literal.
  `$date.set($unit, $value)` as $exp where {
    $unit <: string(fragment=$setter),
    $setter <: or {
      // units in a momentjs getter are case insensitive and allow plural forms
      regex_year() => `setYear`,
      regex_month() => `setMonth`,
      regex_date() => `setDate`,
      regex_hour() => `setHours`,
      regex_minute() => `setMinutes`,
      regex_second() => `setSeconds`,
      regex_ms()  => `setMilliseconds`,
    },
    $comment = `/* TODO: date-fns objects are immutable, propagate this value appropriately */`,
    $out = `datefns.$setter($date, $value)`,
    if ($date <: identifier()) {
      $out = `($date = datefns.$setter($date, $value))`
    } else if ($exp <: should_follow_semi()) {
      $out = `$comment\n$out`
    } else {
      $out = `$comment $out`
    }
  } => `$out`,
  }
}

pattern rewrite_duration_set_and_get() {
  `$duration.$getter()` where {
    $getter <: or {
      `asMilliseconds` => `toMilliseconds`,
      `asSeconds` => `toSeconds`,
      `asMinutes` => `toMinutes`,
      `asHours` => `toHours`,
      `asDays` => `toDays`,
      `asWeeks` => `toWeeks`,
      `asMonths` => `toMonths`,
      `asYears` => `toYears`,
    }
  } => `durationfns.$getter($duration)`,
}

// Some stateful features of moment-js are simply missing in date-fns.
// For example, calling `date.utc(<boolean>)` will set a flag on `date`
// to use UTC to display a moment instead of the original moment's time.
// This only affects the way a date is displayed (PST vs UTC).
// This could technically be migrated by maintaining a global map of flags and
// turning every `utc()` call into `set`, and every `display` call into a custom
// overload, but I think that would introduce too much unwanted noise into the user's program.
pattern missing_datefns_features() {
  `$date.$method()` where {
    $method <: or { `utc`, `local` }
  } => `$date`
}

pattern rewrite_misc_methods() {
  or {
    `$d.toJSON()` => `dateOrDuration2JSON($d)`,
    `$d.clone()` as $exp where {
      $out = `((d => (d instanceof Date) ? (new Date(d.getTime())) : structuredClone(d) )($d))`,
      if ($d <: identifier()) {
        $out = `(($d instanceof Date) ? new Date($d.getTime()) : structuredClone($d))`,
      },
      if ($exp <: should_follow_semi()) {
        $out = `;\n$out`
      }
    } => `$out`,
    `$d.humanize()` => `datefns.formatDuration($d)`,
    missing_datefns_features()
  }
}

pattern rewrite_moment_queries() {
  or {
    `$date_a.$compare($date_b)` where {
      $compare <: or { `isBefore`, `isAfter` }
    } => `datefns.$compare($date_a, $date_b)`,

    `$date_a.$compare($date_b)` where {
      $compare <: or {
        `isSameOrBefore` => `isBefore`,
        `isSameOrAfter` => `isAfter`
      }
    // NOTE: since `a` and `b` are evaluated twice, it is safer to use an IIFE here for correctness.
    } => `((a, b) => datefns.isEqual(a, b) || datefns.$compare(a, b))($date_a, $date_b)`,

    `$date.isBetween($start_date, $end_date)` => `((date) => datefns.isAfter(date, $start_date) && datefns.isBefore(date, $end_date))($date)`,
    `$date.isLeapYear()` => `datefns.isLeapYear($date)`,
    `$isMoment($arg)` where { $isMoment <: or { `$_.isMoment`, `isMoment` }  } => `(($arg) instanceof Date)`,
  }
}

pattern rewrite_moment_distance() {
  `$date.toNow()` => `datefns.formatDistanceToNow($date)`,
  `$date_a.from($date_b)` => `(datefns.formatDistance($date_a, $date_b) + " ago")`,
  `$date_a.to($date_b)` => `datefns.formatDistance($date_a, $date_b)`,
}

pattern rewrite_duration_ctors() {
  or {
    // NOTE: date-fns only provides a `Duration` object ([docs](https://date-fns.org/v2.30.0/docs/Duration)).
    // Curiously, it does not provide any helpers to manipulate these duration objects.
    // For that, we use a third party package called [duration-fns](https://www.npmjs.com/package/duration-fns).
    `$duration_ctor($count, $literal_unit)` where {
      // could be moment.duration(...) (default import) or duration(..)
      $duration_ctor <: or { `$_.duration`, `duration` },
      // TODO: handle the case where the unit is not a literal (or a compile time constant).
      $literal_unit <: or {
        year() => `years`,
        month() => `months`,
        week() => `weeks`,
        day() => `days`,
        hour() => `hours`,
        minute() => `minutes`,
        second() => `seconds`,
        millisecond() => `milliseconds`
      },

      // A duration in `date-fns` is a mapping from time units to values (e.g: { years: 1 }).
      // NOTE: This is an implementation detail, and is not documented in the library itself,
      // but date-fns does not expose any way to construct a duration by fiat.
      // Complementary libraries like `duration-fns` also rely on this internal representation, though.
      // So we should be good here.
      // ([source](https://github.com/date-fns/date-fns/blob/817ce9fda6dc11336923f80b45d34bf7c5a57886/src/types.ts#L58))
    } => `({ $literal_unit: $count })`,

    `$duration_ctor($args)` where {
      $duration_ctor <: or { `$_.duration`, `duration` },
      $out = `({})`,
      if ($args <: [$arg]) { // one argument => string or object 
        $out = `makeDuration($arg)`
      } else if ($args <: [$count, $unit]) { // two args => value and unit
        $out = `({ [normalizeMomentJSUnit($unit)]: $count })`
      } else {
        $out = `({})`
      }
    } => `$out`
  }
}

pattern rewrite_const_to_let() {
  moment_const_decl($declaration, $declarators) where { $declaration => `let $declarators` }
}

pattern rewrite_moment_imports() {
  or {
    `const $id = require("moment")` => `const datefns = require("date-fns");\nconst durationfns = require("duration-fns")`,
    // TODO: only add a default import of `duration-fns` if neccessary.
    `import $_ from "moment"` => `import datefns from "date-fns";\n import durationfns from "duration-fns";`,
  }
}


pattern moment_exp_to_datefns_exp() {
  or {
    // TODO: back-track the origin of an identifier and mutate the declaration on-demand.
    moment_const_decl($declaration, $declarators) where { $declaration => `let $declarators` },

    // Formatting
    `$date.format($fmt)` as $fmt_exp where {
      $date <: identifier(),
      $fmt_exp => `($date = $date.format($fmt))`
    },

    // parsing:
    // date-fns uses different format to parse dates.
    // https://github.com/date-fns/date-fns/blob/main/docs/unicodeTokens.md
    // momentjs: https://momentjs.com/docs/#/parsing/string-format/
    // TODO: This needs more work, the two format specifications have more differences.
    `moment($str, $fmt)` => `datefns.parse($str, ($fmt).replace(/D/g, "d").replace(/Y/g, "y").replace(/h/g, "H").replace(/x/g, "T"), new Date())`,
    
    // construction
    `moment($arg)` as $exp where {
      $out = `new Date($arg)`,
      if ($exp <: should_follow_semi()) {
        $out = `($out)`
      }
    } => `$out`,

    // convert all .add/.sub calls to date-fns equivalent calls.
    rewrite_moment_arithmetic(),

    // start/end setters where the time unit is a literal (e.g: d.startOf("week"))
    moment_set_to_start_or_end_literal($date, $func_type, $unit) as $expression where {
      $unit_name = `Year`,
      $setter_fn = `setYear`,

      if ($unit <: regex_month()) {
        $unit_name = `Month`,
        $setter_fn = `setMonth`,
      } else if ($unit <: regex_week()) {
        $unit_name = `Week`,
        $setter_fn = `setWeek`
      } else if ($unit <: regex_day()) {
        $unit_name = `Day`,
        $setter_fn = `setDay`
      } else if ($unit <: regex_hour()) {
        $unit_name = `Hour`,
        $setter_fn = `setHours`
      } else if ($unit <: regex_minute()) {
        $unit_name = `Minute`,
        $setter_fn = `setMinutes`
      } else if ($unit <: regex_second()) {
        $unit_name = `Second`,
        $setter_fn = `setSeconds`
      },

      $setter = `datefns.$setter_fn`,
      $getter = `datefns.$func_type$unit_name`,
      $comment = `/* TODO: date-fns objects are immutable, propagate this value appropriately */`,

      $out = `((date => $setter(date, $getter(date)))($date))`,
      if ($date <: identifier()) {
        $out = `$date = $setter($date, $getter($date))`,
        if ($date <: not within expression_statement($expression)) {
          $out = `($out)`
        }
      } else if ($expression <: should_follow_semi()) {
        $out = `;\n$comment\n$out;`
      }
    } => `$out`,

    // date.max(other_date) -> (date = datefns.max(date, other_date))
    moment_limit_to_max_or_min($date, $arg, $methodName) as $expression where {
      $out = `datefns.$methodName([$date, $arg])`,
      if ($date <: identifier()) {
        $out = `$date = $out`,
        if ($expression <: not should_follow_semi()) {
          $out = `($out)`
        }
      }
    } => `$out`,

    // distance to/from a given date.
    rewrite_moment_distance(),
    
    `$date.unix()` => `datefns.getUnixTime($date)`,
    `$date.daysInMonth()` => `datefns.getDaysInMonth($date)`,
    `$date.toDate()` => `($date)`,
    `$date.toISOString()` => `datefns.formatISO($date)`,
    `$date.toObject()` => `((d => ({ years: datefns.getYears(d), months: datefns.getMonths(d), hours: datefns.hours(d), minutes: datefns.minutes(d), seconds: datefns.seconds(d), milliseconds: datefns.getMilliseconds(d) }))($date))`,

    // Queries:
    rewrite_moment_queries(),

    // Durations API
    rewrite_duration_ctors(),

    // convert all specific getters/setters to date-fns equivalent
    // TODO: Using a helper, convert `.get`/`.set` calls where the argument isn't a literal.
    // e.g: `moment().get(alert())`.
    rewrite_moment_getters_and_setters(),
    rewrite_duration_set_and_get(),

    // rewrite util functions that do not belong to any specific category.
    rewrite_misc_methods(),
  }
}

pattern add_helper_functions() {
  program() as $prog where {
    $dateOrDurationToJSON = `function dateOrDuration2JSON(d) {
  if (d instanceof Date) {
    return datefns.formatISO(d);
  } else if (durationfns.UNITS.some((unit) => Object.hasOwnProperty.call(d, unit))) {
    return durationfns.toJSON(d)
  }

  return d.toJSON()
}`,
  $makeDuration = `function makeDuration(duration) {
  if (typeof duration === 'string') {
    return durationfns.parse(duration)
  } else if (typeof duration === 'number') {
    return { milliseconds: duration }
  } else if (typeof duration === 'object') {
    return duration
  }

  throw new Error("Invalid argument to duration constructor: " + typeof duration)
}`,

  // Is there a better way to have blackslashes inside code snippets?
  $rx_begin = "/\\b",
  $rx_end = "\\b/",

  $normalizeMomentJSUnit = `function normalizeMomentJSUnit(fmt) {
  const unitRegexs = [
    [$rx_begin(?:y|years?)$rx_end, 'year'],
    [$rx_begin(?:q|quarters?)$rx_end, 'quarter'],
    [$rx_begin(?:M|months?)$rx_end, 'month'],
    [$rx_begin(?:w|weeks?)$rx_end, 'week'],
    [$rx_begin(?:d|days?)$rx_end, 'day'],
    [$rx_begin(?:h|hours?)$rx_end, 'hour'],
    [$rx_begin(?:m|minutes?)$rx_end, 'minute'],
    [$rx_begin(?:s|seconds?)$rx_end, 'second'],
    [$rx_begin(?:ms|millisecond?)$rx_end, 'millisecond'],
  ];


  for (const [regex, normalized] of unitRegexs) {
    if (regex.test(fmt)) {
      return normalized;
    }
  }

  return null;
}`,

  $addDate = `function addDate(dateOrDuration, duration) {
  if (dateOrDuration instanceof Date) {
    return add(dateOrDuration, duration)
  } 
  return durationfns.sum(dateOrDuration, duration)
}`,

  $subDate = `function subDate(dateOrDuration, duration) {
  if (dateOrDuration instanceof Date) {
    return sub(dateOrDuration, duration)
  }
  return durationfns.subtract(dateOrDuration, duration)
}`,

    $out = `$prog`,
    if ($prog <: contains `dateOrDuration2JSON($_)`) {
      $out = `$out\n/* Helper function inserted by Grit */\n$dateOrDurationToJSON`
    },
    
    if ($prog <: contains `makeDuration($_)`) {
      $out = `$out\n/* Helper function inserted by Grit */\n$makeDuration`
    },

    if ($prog <: contains `normalizeMomentJSUnit($_)`) {
      $out = `$out\n/*Helper function inserted by Grit - normalize moment JS unit specifier */\n$normalizeMomentJSUnit`
    },

    if ($prog <: contains `addDate($_)`) {
      $out = `$out\n\n$addDate`
    },

    if ($prog <: contains `subDate($_)`) {
      $out = `$out\n\n$subDate`
    }
 
  } => `$out`
}
