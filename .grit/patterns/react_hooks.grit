engine marzano(0.1)
language js

pattern handle_ref($statements, $statement, $name, $type) {
  $value where {
    or {
      and {
        or {
          // The type has an undefined, so our ref type must be undefined
          and {
              $statement <: contains js"?",
              $type <: type_annotation(type=$annotated),
              $annotated <: not contains js"undefined",
              $inner_type = js"$annotated | undefined"
          },
          // We have a type annotation, use this
          $type <: type_annotation(type = $inner_type),
          // Fall back to creating an inner_type this way
          and {
              $statement <: contains js"createRef",
              $statement <: contains or {
                  type_identifier(),
                  predefined_type()
              } as $inner_type
          }
        },
        // We have our type and our ref, so now create the statement
        $statements += `const $name = useRef<$inner_type>($value);`
      },
      and {
        // Type can't be located, initialize `useRef` without a type
        $type <: .,
        $statements += `const $name = useRef($value);`
      },
      // We some have a type, so try to use it
      $statements += `const $name = useRef<$type>($value);`
    }
  }
}

pattern handle_one_statement($class_name, $statements, $states_statements, $static_statements, $render_statements, $constructor_statements, $handler_callback_suffix, $use_ref_from) {
    or {
        method_definition($static, $async, $name, $body, $parameters) as $statement where or {
            and {
                $name <: js"constructor",
                $body <: maybe contains bubble($constructor_statements) {
                    lexical_declaration($declarations) as $decl where $declarations <:
                        variable_declarator($name, $value) where {
                            $name <: not contains js"this.state",
                            $value <: not contains js"this.state",
                            $constructor_statements += $decl
                        }
                },
                $body <: change_this($states_statements)
            },
            and {
                $statement <: prepend_comment($statements),
                $name <: or { `componentDidUpdate`, `componentDidMount` },
                $body <: change_this($states_statements),
                $statements += `useEffect(() => $body, []);`
            },
            and {
                $statement <: prepend_comment($statements),
                $name <: `componentWillUnmount`,
                $body <: change_this($states_statements),
                $statements += `useEffect(() => {\n    return () => $body;\n}, []);`
            },
            and {
                $name <: `render`,
                $body <: statement_block(statements = $render_statements)
            },
            and {
                $statement <: prepend_comment(statements=$static_statements),
                $static <: `static`,
                $body <: change_this($states_statements),
                $static_statements += `$class_name.$name = $parameters => $body;`
            },
            and {
                $statement <: prepend_comment($statements),
                $async <: `async`,
                if ($handler_callback_suffix <: .) {
                  $statements += `const ${name} = async $parameters => $body;`
                } else {
                  $statements += `const ${name}${handler_callback_suffix} = useCallback(async $parameters => $body, []);`
                }
            },
            and {
                $statement <: prepend_comment($statements),
                $statement <: after `@computed`,
                $statements += `const ${name} = useMemo(() => $body, []);`
            },
            and {
                $statement <: prepend_comment($statements),
                $statement <: contains js"get",
                $statements += `const ${name} = useMemo(() => $body, []);`
            },
            and {
                $statement <: prepend_comment($statements),
                if ($handler_callback_suffix <: .) {
                  $statements += `const ${name} = $parameters => $body;`
                } else {
                  $statements += `const ${name}${handler_callback_suffix} = useCallback($parameters => $body, []);`
                }
            }
        },
        public_field_definition($static, $name, $value, $type) as $statement where or {
            and {
                $value <: contains or { `reaction($_, $effect_function)`, `reaction($_, $effect_function, $_)` },
                $effect_function <: or { `($_) => $effect` , `() => $effect` },
                $statements += `useEffect(() => $effect, []);`
            },
            and {
                $value <: object($properties),
                $name <: `defaultProps`,
                $statements += `const props = { \n    $properties,\n    ...inputProps,\n  };`
            },
            and {
                $static <: `static`,
                or {
                    and {
                        $value <: .,
                        $after_value = `undefined`,
                    },
                    $after_value = $value,
                },
                $statement <: prepend_comment(statements=$static_statements),
                $static_statements += `$class_name.$name = $after_value;`
            },
            and {
                $statement <: after `@observable`,
                $capitalized = capitalize(string = $name),
                or {
                    and {
                        $value <: .,
                        $after_value = `undefined`,
                    },
                    $after_value = $value,
                },
                or {
                    and {
                        $type <: type_annotation(type = $inner_type),
                        $states_statements += `const [$name, set$capitalized] = useState<$inner_type>($after_value);`
                    },
                    and {
                        $states_statements += `const [$name, set$capitalized] = useState($after_value);`
                    }
                }
            },
            and {
                $value <: arrow_function(),
                if ($handler_callback_suffix <: .) {
                  $statements += `const ${name} = $value;`
                } else {
                  $statements += `const ${name}${handler_callback_suffix} = useCallback($value, []);`
                }
            },
            and {
                $name <: js"state",
                $value <: object($properties) where {
                    $properties <: contains bubble($states_statements) pair($key, value=$val) where {
                        $capitalized = capitalize(string = $key),
                        $states_statements += `const [$key, set$capitalized] = useState($val);`
                    }
                }
            },
            // Handle explicit createRef calls
            and {
                // Handle explicit createRef calls
                $statement <: prepend_comment($statements),
                $value <: or {
                    js"React.createRef($ref)",
                    js"createRef($ref)",
                },
                $ref <: handle_ref($statements, $statement, $name, $type)
            },
            and {
                // If we have a use_ref_from, we can use it to wrap values
                !$use_ref_from <: .,
                $statement <: prepend_comment($statements),
                or {
                    and {
                        $value <: .,
                        $after_value = `undefined`,
                    },
                    $after_value = $value,
                },
                $statements += js"const $name = useRefFrom(() => $after_value).current"
            },
            and {
                // our final fallback is to wrap it in a useRef
                $statement <: prepend_comment($statements),
                $value <: handle_ref($statements, $statement, $name, $type)
            },
        },
    }
}
pattern prepend_comment($statements) {
    maybe after comment() as $comment where {
        $statements += js"$comment"
    }
}
pattern change_this($states_statements) {
    maybe contains or {
        assignment_expression(
            left = `this.state`,
            right = object (
                properties = some bubble($states_statements) pair($key, $value) where {
                $capitalized = capitalize(string = $key),
                $states_statements += `const [$key, set$capitalized] = useState($value);`
            }
            )
        ) => .,
        variable_declarator(
            name = object_pattern(properties = some bubble($states_statements) $prop where {
                $capitalized = capitalize(string = $prop),
                $states_statements += `const [$prop, set$capitalized] = useState();`
            }),
            value = `this.state`
        ) => .
    }
}
pattern gather_hooks($hooks) {
    contains or {
        `useEffect` where {
            $hooks <: not some `useEffect`,
            $hooks += `useEffect`
        },
        `useCallback` where {
            $hooks <: not some `useCallback`,
            $hooks += `useCallback`
        },
        `useState` where {
            $hooks <: not some `useState`,
            $hooks += `useState`
        },
        `useRef` where {
            $hooks <: not some `useRef`,
            $hooks += `useRef`
        }
    }
}

pattern add_more_imports($use_ref_from) {
  $statements where {
    $more_imports = "",
    // If we use MobX, insert it
    if (and {
      $program <: contains `observer($_)`,
      $program <: not contains js"mobx-react"
    }) {
      $more_imports += `import { observer } from "mobx-react";`
    },
    // If we have useRefFrom, use it
    if (and {
      $program <: contains js"useRefFrom",
      !$use_ref_from <: .
    }) {
      $more_imports += `import { useRefFrom } from $use_ref_from';`
    },
  } => `$more_imports\n$statements`
}

pattern adjust_imports($use_ref_from) {
    maybe and {
        $hooks = [],
        gather_hooks($hooks),
        $hooks = join(list = $hooks, separator = ", "),
        or {
            // ugly dealing with imports
            contains import_specifier(name = `Component`) => `$hooks`,
            contains `import React from 'react'` as $i where {
                $i <: not contains namespace_import(),
                $i => `import React, { $hooks } from 'react';`
            },
            contains `import React from "react"` as $i where {
                if ($i <: not contains namespace_import()) {
                    $i => `import React, { $hooks } from 'react';`
                } else {
                    $i => `$i\nimport { $hooks } from 'react';`
                }
            }
        }
    }
}
pattern maybe_wrapped_class_declaration($class_name, $body, $class) {
    or {
        export_statement(declaration = class_declaration(name = $class_name, $body, $heritage) as $class),
        class_declaration(name = $class_name, $body, $heritage) as $class
    } where {
        $heritage <: contains extends_clause(value = contains `Component`)
    }
}
pattern first_step() {
    maybe_wrapped_class_declaration($class_name, $body, $class) where {
        $statements = [],
        $constructor_statements = [],
        $states_statements = [],
        $static_statements = [],
        $use_ref_from = .,
        if ($body <: contains js"$class_name.$name = $_" ) {
            $static_statements += raw`/*\n* TODO: Class component's static variables are reassigned, needs manual handling\n*/`,
        },
        if ($class <: contains extends_clause(type_arguments = contains type_arguments($types))) {
            or {
                $types <: [$props_type, $state_type, ...],
                and {
                    $types <: [$props_type, ...],
                    $state_type = .
                }
            },
            $type_annotation = `: $props_type`,
        } else {
            $props_type = `{}`,
            $type_annotation = .,
            $state_type = .
        },
        // todo: replace contains with list pattern match once we have the field set
        // we are missing a field for the statements in class_body

        // Set an alternative callback suffix, or remove it entirely
        $handler_callback_suffix="Handler",

        $body <: contains handle_one_statement($class_name, $statements, $states_statements, $static_statements, $render_statements, $constructor_statements, $handler_callback_suffix, $use_ref_from),
        $program <: maybe contains interface_declaration(body=$interface, name=$interface_name) where {
            $state_type <: $interface_name,
            $interface <: contains bubble($states_statements, $body) {
                property_signature($name, $type) where {
                    $type <: type_annotation(type = $inner_type),
                    $capitalized = capitalize(string = $name),
                    $body <: not contains or {
                        public_field_definition(name=$public_name, $value) where or {
                            $public_name <: $name,
                            and {
                                $public_name <: js"state",
                                $value <: contains $name
                            }
                        },
                        method_definition(name=$method_name) where {
                            $method_name <: js"constructor",
                            $body <: contains  or {
                                `this.state.$name = $_`,
                                js"this.state = $obj" where $obj <: contains pair(key=$name)
                            }
                        }
                    },
                    $states_statements += `const [$name, set$capitalized] = useState<$inner_type | undefined>(undefined);`
                }
            }
        },
        $body <: not contains `componentDidCatch`,
        $class <: not within class_declaration(name = not $class_name),

        if ($body <: contains `static defaultProps = $default_props`) {
            $the_props = "inputProps"
        } else {
            $the_props = "props"
        },

        $const_type_annotation = .,
        if ($program <: contains `FunctionComponent`) {
            $const_type_annotation = `: React.FunctionComponent<${props_type}>`,
            $type_annotation = .
        },

        if ($body <: contains `props`) {
            $args = `${the_props}${type_annotation}`
        } else {
            $args = .
        },

        $separator = `\n    `,
        // a bit of hack because we cannot use a code snippet as an argument to a builtin function yet
        $separator += "",
        $states_statements = join(list = $states_statements, $separator),
        $statements = join(list = $statements, $separator),
        $constructor_statements = join(list = $constructor_statements, $separator),
        $the_function = `($args) => {\n$constructor_statements\n\n    $states_statements\n\n    ${statements}\n\n    ${render_statements} \n}`,

        // Construct the final class name
        $original_name = $class_name,
        if ($body <: contains r"(v|V)iewState"($_)) {
            $base_name = js"${class_name}Base",
            $the_const = `const $base_name$const_type_annotation = $the_function;

export const $original_name = observer($base_name);`,
        } else {
            $the_const = `const $class_name$const_type_annotation = $the_function;`
        },

        $static_statements = join(list = $static_statements, $separator),
        $class => `$the_const\n\n$static_statements\n`
    }
}
pattern find_dependencies($hoisted_states, $dependencies) {
    contains bubble($hoisted_states, $dependencies) identifier() as $i where {
        $i <: not `props`,
        $hoisted_states <: some $i,
        $dependencies <: not some $i,
        $dependencies += `$i`
    }
}
pattern rewrite_accesses($hoisted_states, $hoisted_refs, $use_memos) {
    or {
        `this.state.$x` => `$x`,
        `this.$property` as $p where {
            if (or {
                $hoisted_states <: some $property,
                $use_memos <: some $property
            }) {
                $p => `${property}`
            } else if ($hoisted_refs <: some $property) {
                or {
                    and {
                        $property <: within member_expression() as $already_ref where $already_ref <: {
                            js"$p.current"
                        },
                        $p => `${property}`
                    },
                    $p => `${property}.current`
                }
            } else {
                $p => `${property}Handler`
            }
        },
        lexical_declaration(declarations = [variable_declarator(value = or { `this.state`, `this` })]) => .,
        assignment_expression($left, $right) as $assignment where or {
            and {
                $hoisted_refs <: some $left,
                $assignment => `$left.current = $right`
            },
            and {
                $hoisted_states <: some $left,
                $capitalized = capitalize(string = $left),
                $assignment => `set${capitalized}($right)`
            },
        },
        `this.setState($x)` as $set_state where {
            $statements = [],
            $x <: contains bubble($statements) or {
                pair(key = $key, value = $value) where {
                    $capitalized = capitalize(string = $key),
                    $statements += `set$capitalized($value);`
                },
                shorthand_property_identifier() as $identifier where {
                    $capitalized = capitalize(string = $identifier),
                    $statements += `set$capitalized($identifier);`
                }
            },
            $separator = `\n    `,
            // a bit of hack because we cannot use a code snippet as an argument to a builtin function yet
            $separator += "",
            $statements = join(list = $statements, $separator),
            $set_state => `$statements`
        },
        // to deactivate dependency detection, comment out the following lines
        `$method($f, $dependencies_array)` where {
            $method <: or { `useEffect`, `useCallback`, `useMemo` },
            $dependencies = [],
            $f <: find_dependencies($hoisted_states, $dependencies),
            $dependencies = join(list = $dependencies, separator = ", "),
            $dependencies_array => `[$dependencies]`
        },
        // clean-up props arg -- not needed if only used in constructor, and first step introduced it
        // if it sees it anywhere in the pattern
        arrow_function(parameters=$props, body=$body) where {
            $props <: contains or { `props`, `inputProps` },
            $body <: not contains `props`,
            $props => `()`
        }
    }
}
pattern gather_accesses($hoisted_states, $hoisted_refs, $use_memos) {
    contains bubble($hoisted_states, $hoisted_refs, $use_memos) variable_declarator($name, $value) where {
        or {
            and {
                $name <: array_pattern(elements = [$used_name, $_]),
                $value <: `useState($_)`,
                $hoisted_states += $name
            },
            and {
                $name <: $used_name,
                $value <: `useRef($_)`,
                $hoisted_refs += $name
            },
            and {
                $name <: $used_name,
                $value <: `useMemo($_)`,
                $use_memos += $name
            }
        },
    },
    contains bubble($hoisted_states, $hoisted_refs, $use_memos) or {
        variable_declarator(
            name = array_pattern(elements = [$name, $_]),
            value = `useState($_)`
        ) as $var where {
            $var <: not within object()
        } where $hoisted_states += $name,
        variable_declarator(
            name = $name,
            value = `useRef($_)`
        ) as $var where {
            $var <: not within object()
        } where $hoisted_refs += $name,
        variable_declarator(
            name = $name,
            value = `useMemo($_)`
        ) as $var where {
            $var <: not within object()
        } where $use_memos += $name,
    }
}
pattern second_step() {
    maybe and {
        $hoisted_states = [],
        $hoisted_refs = [],
        $use_memos = [],
        $hoisted_states += `props`,
        program($statements) where {
            and {
                $statements <: maybe gather_accesses($hoisted_states, $hoisted_refs, $use_memos),
                $statements <: some or {
                    export_statement(
                        decorator = contains `@observer` => .,
                        declaration = lexical_declaration(declarations = contains rewrite_accesses($hoisted_states, $hoisted_refs, $use_memos))
                    ),
                    export_statement(
                        declaration = lexical_declaration(declarations = contains rewrite_accesses($hoisted_states, $hoisted_refs, $use_memos))
                    ),
                    lexical_declaration(declarations = contains rewrite_accesses($hoisted_states, $hoisted_refs, $use_memos))
                }
            }
        }
    }
}
